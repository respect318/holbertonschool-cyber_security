##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner

  def initialize
    super(
      'Name'        => 'Custom Port Scanner',
      'Description' => 'Scans a range of ports on a target system and identifies open ports.',
      'Author'      => ['Me'],
      'License'     => MSF_LICENSE
    )

    register_options(
      [
        OptInt.new('STARTPORT', [true, 'Start port', 1]),
        OptInt.new('ENDPORT', [true, 'End port', 1024])
      ]
    )

    deregister_options('RPORT')
  end

  def run_host(ip)
    start_port = datastore['STARTPORT']
    end_port = datastore['ENDPORT']
    open_ports = []

    (start_port..end_port).each do |port|
      begin
        # Attempt to connect to the specific port
        # We pass false for 'global' to avoid updating the global RPORT option
        sock = connect(false, 'RPORT' => port)
        
        # If connection is successful
        print_good("#{ip} - Port #{port} is open on #{ip}")
        open_ports << port
        
        # Always disconnect after a successful check
        disconnect(sock)
      rescue Rex::ConnectionRefused, Rex::HostUnreachable, Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::EPIPE
        # Port is closed, filtered, or unreachable; do nothing
      rescue => e
        # Handle unexpected errors safely
        vprint_error("Error connecting to #{ip}:#{port} - #{e.message}")
      end
    end

    unless open_ports.empty?
      print_status("#{ip} - Open ports on #{ip}: #{open_ports.join(', ')}")
    end
  end
end
